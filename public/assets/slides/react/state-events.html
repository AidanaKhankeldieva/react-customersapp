<!DOCTYPE html>
<html>
  <head>
    <title>State, Events, and Forms</title>
    <meta charset="utf-8">
    <style>
        .remark-slide-scaler {
            width: 100% !important;
            height: 100% !important;
            transform: scale(1) !important;
            left: 0 !important;
            top: 0 !important;
        }
      @import url(https://fonts.googleapis.com/css?family=Raleway);
      @import url(https://fonts.googleapis.com/css?family=Lato:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Inconsolata:400,700,400italic);

      body {
          font-family: 'Lato';
      }

      h1, h2, h3 {
        font-family: 'Raleway';
        font-weight: normal;
      }

      .remark-code, .remark-inline-code {
          font-family: 'Inconsolata';
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# State, Events, and Forms

---

## Recap

* Last session, we learned:
    * Props - The mechanism by which parent components pass data down to child components
    * Components - The main building block in React applications, which accept Props and return React elements *that describe what should appear on the screen*

```javascript
Components = Props => Elements
```

???

* Friendly reminder that React is declarative

---

## State

* We will now learn about using state to manage data that will change in our application
* We will evolve our mental model of components

```javascript
Components = (Props, State) => Elements
```

* State is generally used to manage data that is encapsulated with a component

???

* Most non-presentational components need to have some kind of state - we will see an example of the distinction later

---

## Timer Component - Basic Setup

```jsx
class Clock extends React.Component {
  render() {
    return (
      <div>It is {new Date().toLocaleString()}</div>
    );
  }
}
```

* We create a basic ES6 class that extends React.Component with a `render` method
    * This allows us to use additional features - namely local state and lifecycle hooks

---

## Timer Component - Initial State

```jsx
class Clock extends React.Component {
*  constructor(props) {
*    super(props);
*
*    this.state = { date: new Date().toLocaleString() };
*  }

  render() {
*    const { date } = this.state;

    return (
*      <div>It is {date}</div>
    );
  }
}
```

* We first add local state by initializing it in the constructor
    * Note that the constructor takes in props and calls the `React.Component` constructor with props
* We then use the date from the `this.state` object to render our element
    * Only ES6 class components can have state, functional components cannot

---

## (Briefly) Lifecycle Hooks

* There are [a lot of lifecycle hooks](https://reactjs.org/docs/react-component.html#the-component-lifecycle) - we will only cover the ones we need for the timer
    * The two we need are (in my experience) two of the more frequently used lifecycle hooks
* Like state, lifecycle hooks are only available to ES6 class components
* Hooks
    * [componentDidMount](https://reactjs.org/docs/react-component.html#componentdidmount) is invoked immediately after a component is mounted
    * [componentWillUnmount](https://reactjs.org/docs/react-component.html#componentwillunmount) is invoked immediately before a component is unmounted and destroyed

???

* Last time, Yi asked about why we use class components instead of functional components or vice versa, the two major reasons are state and lifecycle hooks
    * The React team has said that in the future, functional components could also have performance benefits - they are currently turned into classes by the transpiler so they are the same as far as performance is concerned
* We will use componentDidMount to start the tick when the component mounts and componentWillUnmount to stop the tick when the component unmounts

---

## Timer Component - Lifecycle

```jsx
class Clock extends React.Component {
  componentDidMount() {
    this.timerId = setInterval(
      () => this.setState({ time: new Date().toLocaleString() }),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerId);
  }

  // render and constructor unchanged
}
```

* We use `setState` to update state instead of setting this.state directly
    * This allows React to batch multiple state updates for performance reasons
    * As a result, state updates via `setState` *may* be asynchronous
    * **Important:** Do not set `this.state` directly anywhere except for the constructor
* Note that we set the `timerId` property directly on the instance - this is allowed as long as we do not clash with React's properties (`props` or `state`)

---

## Minor Refactoring

```jsx
class Clock extends React.Component {
* static getDate = () => new Date().toLocaleString()

  constructor(props) {
    super(props);

    this.state = { date: Clock.getDate() };
  }

  componentDidMount() {
    this.timerId = setInterval(
      () => this.setState({ time: Clock.getDate() }),
      1000
    );
  }

  // render and componentWillUnmount unchanged
}
```

* The `getDate` function does not use `this`, so we can make it a static method on `Clock`

---

## More Minor Refactoring

```jsx
class Clock extends React.Component {
  componentDidMount() {
*   this.timerId = setInterval(this.tick, 1000);
  }

  tick = () => this.setState({ time: Clock.getDate() })

  // getDate, constructor, componentWillUnmount, and render unchanged
}
```

* We can extract the `tick` function for clarity, since it uses `this`, we need to make it a class method

---

## Events

* React implements [a wrapper around native browser events](https://reactjs.org/docs/events.html)
    * This helps to deal with some of the inconsistencies between modern browsers
* There are *a lot* of different types of events, we will not cover most of them. An exhaustive list is available [here](https://reactjs.org/docs/events.html#supported-events)

---

## Forms And Events

* Let's build a simple form to tie all the concepts that we have learned together

```jsx
class Form extends React.Component {
  onInputChange = event => console.log(event.target.value)

  render() {
    return (
      <div>
        <input
          type="text"
          onChange={onInputChange}
        />
      </div>
    );
  }
}
```

* We add a listener to the `onChange` event - this function will get called each time the value in the input changes
* The `event` value has a lot of fields - to track the new value of the form after the change, we use `event.target.value`
* **IMPORTANT:** Always define arrow functions outside of the render function - this can break performance optimizations that we will talk about in the future because arrow functions are reallocated on each call, possibly causing unnecessary rerenders

---

## Forms - Controlled Components 1

* We have reached our first point of tension between the HTML spec and frameworks
    * In HTML, input components typically keep their own state and updates it automatically on user input
    * In React, components typically keep mutable state (ex. form input values) in its state property
* *Idea*: Use React state as the "single source of truth" - this is known as a "controlled component"

???

* We have reached a point of tension between the HTML spec and React
* The controlled component pattern alleviates the need for HTML elements to maintain their own state

---

## Forms - Controlled Components 2

```jsx
class Form extends React.Component {
  constructor(props) {
    super(props);

*   this.state = { inputValue: '' };
  }

* onInputChange = event => this.setState({ inputValue: event.target.value })

  render() {
*   const { inputValue } = this.state;

    return (
      <div>
*       <input type="text" onChange={this.onInputChange} value={inputValue} />
      </div>
    );
  }
}
```

* **Note:** When doing forms with React, the components do not *need* to be controlled - we can get the value directly from the input - this could be advantageous if we are trying to integrate with an external library like jQuery. However, it is generally more advantageous to make a component controlled where possible to avoid solving a problem that React solves for us

???

1. Like before, we set the initial state in the constructor (the input is blank by default)
2. We define the `onInputChange` callback as a class method
3. Like before, we destructure this.state to get the input value
4. We set the `onChange` callback to `this.onInputChange` and set the `value` to be `inputValue`
    * This makes the input element "controlled" - when it changes, it calls the `this.onInputChange` callback, which updates state within the React component and then sets the value of the input element - all state is lifted into the React component

---

## Forms - Multiple Inputs

```jsx
class Form extends React.Component {
  constructor(props) {
    super(props);

    this.state = { input1Value: '', input2Value: '' };
  }

  onInput1Change = event => this.setState({ input1Value: event.target.value })
  onInput2Change = event => this.setState({ input2Value: event.target.value })

  render() {
    const { input1Value, input2Value } = this.state;

    return (
      <div>
        <input type="text" onChange={this.onInput1Change} value={input1Value} />
        <input type="text" onChange={this.onInput2Change} value={input2Value} />
      </div>
    );
  }
}
```

* We just need to replicate what we did with the first input
* *Problem:* Our code is not DRY - let's fix that by extracting input into a component

---

## Forms - Input Component 1

```jsx
const propTypes = {
  onInputChange: PropTypes.func.isRequired,
  inputValue: PropTypes.string.isRequired,
};

const Index = ({ onInputChange, inputValue }) => (
  <input type="text" onChange={onInputChange} value={inputValue} />
);

Index.propTypes = propTypes;
```

* The `Input` component does not have state and does not use lifecycle hooks, so we can make it a functional component
* The parent component supplies the `onInputChange` callback and the `value` field

???

* **DO THIS**: Last time, Jason asked about what happens if a prop is required but it is not provided (demonstrate this)

---

## Forms - Input Component 2

```jsx
import Input from './Input';

class Form extends React.Component {
  render() {
    const { input1Value, input2Value } = this.state;

    return (
      <div>
        <Input onInputChange={this.onInput1Change} inputValue={input1Value} />
        <Input onInputChange={this.onInput2Change} inputValue={input2Value} />
      </div>
    );
  }

  // constructor, onInput1Change, and onInput2Change unchanged
}
```

* We now have a clearer separation of concerns between the form (which handles the values of the inputs) and the inputs (which handles the user-triggered events)

???

* The Input component can now be part of our UI library. Changes in styling (for example) can be applied once and will be applied to all the Input components in our application

---

## Forms - Buttons

```jsx
class Form extends React.Component {
  // In a real application, this could send data to the server
* onButtonClick = () => console.log(
*   this.state.input1Value,
*   this.state.input2Value
* )

  render() {
    const { input1Value, input2Value } = this.state;

    return (
      <div>
        <Input onInputChange={this.onInput1Change} inputValue={input1Value} />
        <Input onInputChange={this.onInput2Change} inputValue={input2Value} />
*       <button onClick={this.onButtonClick}>Submit</button>
      </div>
    );
  }

  // constructor, onInput1Change and onInput2Change unchanged
}
```

* Like before, we define a `button` element, and an `onClick` handler to handle the user clicking on the button
* Note that using a controlled component makes it easier and less error prone to define our `onClick` handler

???

* Instead of querying the input for its value, we can simply use the value that is stored in the component
* We don't have to deal with possible browser compatability issues when it comes to getting the value of an input element

---

## Main References

* https://reactjs.org/docs/state-and-lifecycle.html
* https://reactjs.org/docs/forms.html

## Additional References
#### These were covered partially or in passing

* https://reactjs.org/docs/react-component.html#the-component-lifecycle
* https://reactjs.org/docs/react-component.html#componentdidmount
* https://reactjs.org/docs/react-component.html#componentwillunmount
* https://reactjs.org/docs/events.html
* https://reactjs.org/docs/events.html#supported-events

---

## Questions

*

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
          highlightLines: true,
      });
    </script>
  </body>
</html>
